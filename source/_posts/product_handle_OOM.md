---

title: 线上问题处理-OOM
data: 2017-11-29
categories: accident handling,linux
tags: [accident handling,linux]

---

某服务器上部署了Java服务一枚，出现了OutOfMemoryError，请问有可能是什么原因，问题应该如何定位？

**解决思路**   
Java服务OOM，最常见的原因为：  
•	有可能是内存分配确实过小，而正常业务使用了大量内存   
•	某一个对象被频繁申请，却没有释放，内存不断泄漏，导致内存耗尽  
•	某一个资源被频繁申请，系统资源耗尽，例如：不断创建线程，不断发起网络连接  
 
更具体的，可以使用以下的一些工具逐一排查。

**一、确认是不是内存本身就分配过小**
方法：jmap -heap 10765
![jmap_linux.png](https://i.loli.net/2017/12/06/5a279f80b43d8.png)  
如上图，可以查看新生代，老生代堆内存的分配大小以及使用情况，看是否本身分配过小

**二、找到最耗内存的对象**
方法：jmap -histo:live 10765 | more  
![jmap_histo_linux.png](https://i.loli.net/2017/12/06/5a279fdca45d2.png)  
如上图，输入命令后，会以表格的形式显示存活对象的信息，并按照所占内存大小排序：  
•	**实例数**  
•	**所占内存大小**  
•	**类名**  
是不是很直观？对于实例数较多，占用内存大小较多的实例/类，相关的代码就要针对性review了。  
 
上图中占内存最多的对象是RingBufferLogEvent，共占用内存18M，属于正常使用范围。  

如果发现某类对象占用内存很大（例如几个G），很可能是类对象创建太多，且一直未释放。例如：  
•	申请完资源后，未调用close()或dispose()释放资源  
•	消费者消费速度慢（或停止消费了），而生产者不断往队列中投递任务，导致队列中任务累积过多  


**三、确认是否是资源耗尽**

工具：  
•	pstree  
•	netstat  
查看进程创建的线程数，以及网络连接数，如果资源耗尽，也可能出现OOM。  
 
这里介绍另一种方法，通过  
•	/proc/${PID}/fd  
•	/proc/${PID}/task  
可以分别查看句柄详情和线程数。  
 
例如，某一台线上服务器的sshd进程PID是9339，查看  
•	ll /proc/9339/fd  
•	ll /proc/9339/task  

![proc_linux.png](https://i.loli.net/2017/12/06/5a27a09940d82.png)

如上图，sshd共占用了四个句柄  
•	0 -> 标准输入  
•	1 -> 标准输出  
•	2 -> 标准错误输出  
•	3 -> socket（容易想到是监听端口）  
 
sshd只有一个主线程PID为9339，并没有多线程。  


所以，只要  
•	ll /proc/${PID}/fd | wc -l  
•	ll /proc/${PID}/task | wc -l （效果等同pstree -p | wc -l）
就能知道进程打开的句柄数和线程数。



